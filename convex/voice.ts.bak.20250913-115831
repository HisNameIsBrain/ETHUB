import { buildServiceSearch } from "@/lib/search";
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const startSession = mutation({
  args: {
    model: v.optional(v.string()),
    ua: v.optional(v.string()),
    path: v.optional(v.string()),
    userId: v.optional(v.string()),
  },
  handler: async (ctx, { model, ua, path, userId }) => {
    const sessionId = await ctx.db.insert("voiceSessions", {
      model,
      ua,
      path,
      userId,
      startedAt: Date.now(),
      status: "open",
    });
    await ctx.db.insert("voiceLogs", {
      sessionId,
      ts: Date.now(),
      type: "session_open",
      payload: { model },
    });
    return { sessionId };
  },
});

export const logEvent = mutation({
  args: {
    sessionId: v.id("voiceSessions"),
    type: v.string(),
    payload: v.optional(v.any()),
  },
  handler: async (ctx, { sessionId, type, payload }) => {
    // guard existence
    const sess = await ctx.db.get(sessionId);
    if (!sess) throw new Error("Unknown session");
    await ctx.db.insert("voiceLogs", {
      sessionId,
      ts: Date.now(),
      type,
      payload,
    });
    return { ok: true };
  },
});

export const endSession = mutation({
  args: {
    sessionId: v.id("voiceSessions"),
    reason: v.optional(v.string()), // "user_closed" | "error" | ...
  },
  handler: async (ctx, { sessionId, reason }) => {
    const sess = await ctx.db.get(sessionId);
    if (!sess) return { ok: true }; // already gone
    await ctx.db.patch(sessionId, { endedAt: Date.now(), status: "closed", search: buildServiceSearch({ endedAt: Date.now(), status: "closed" }) });
    await ctx.db.insert("voiceLogs", {
      sessionId,
      ts: Date.now(),
      type: "session_close",
      payload: { reason },
    });
    return { ok: true };
  },
});

// Simple analytics example: last 50 logs of a session
export const getSessionLogs = query({
  args: { sessionId: v.id("voiceSessions") },
  handler: async (ctx, { sessionId }) => {
    return await ctx.db
      .query("voiceLogs")
      .withIndex("by_session", (q) => q.eq("sessionId", sessionId))
      .order("desc")
      .take(50);
  },
});
